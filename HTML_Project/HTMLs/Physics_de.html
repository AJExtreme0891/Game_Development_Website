<!DOCTYPE html>
<html lang="de">

<!--The entire head and header part is identical to the starting page-->
	<head>
		<title> The Phyics of Videogames </title>
		<meta charset="utf-8">
		<link rel="icon" href="../Pictures/favicon.png" type="image/png">
		<link rel="stylesheet" href="../Style_Sheets/Info_Pages_Style_Sheet.css">
	</head>
	<body>
			<header id="Header_Wrapper">
		
		<div id="Head_Part"> <p id="title"> Die Physik von Videospielen</p></div>
		
		
		

		<div id="Second_Head"> 
			<table id="table_header"> 
				<tr> <td class="menu_data menu_button">
Menu
<div id="popup_menu">
	<a href="Game_Development_Website_de.html">Zurück zum Start</a>
       	<a href="Basics_de.html">Die Grundlagen</a>
       	<a href="AI_de.html">Spiele KI & Logik</a>
	<a href="Sources_de.html">Quellen</a>
</div>
	
    

</td>
				<td class="menu_data"> <a href="../HTMLs/Sources_de.html">Sources</a> </td> </tr>
			</table>
		</div>
		
				
		
		</header>
	<!--Button to go back to the top-->
<a href="#Placeholder" id="Back_To_Top">Hoch</a>
<a href="Physics.html" id="Switch_Lang_Link">
 <img id="German_Flag" src="../Pictures/English_language.png" alt="Switch to German Icon">
  <p id="Switch_Lang_Label">switch to English</p>
</a>
<!--invisible ELement meant to be a target for scrolling to the top quicker -->
<div id="Placeholder"></div>
	<!--The content of the page starts here-->
		<!--Each section is a different block of text with a heading-->
		
		

<div class="text_blocks overview_section text_block_one">

        

			<!--svg to make a field which you can interact with-->
 <svg
  viewBox="0 0 1000 600"
  width="100%"
  xmlns="http://www.w3.org/2000/svg"
>
  <!-- Background image -->
  <image
    href="../Pictures/Preview_Physics.png"
    x="0"
    y="0"
    width="1000"
    height="600"
  />

  <a href="#Rigid_Bodies">
  <rect
    x="120"
    y="50"
    width="150"
    height="100"
    fill="rgba(0, 0, 255, 0)"
	/></a>
<a href="#Rigid_Bodies">
  <rect
    x="50"
    y="150"
    width="270"
    height="280"
    fill="rgba(0, 0, 255, 0)"
	/></a>



	  <a href="#Collisions">
  <rect
    x="370"
    y="170"
    width="225"
    height="50"
    fill="rgba(0, 0, 255, 0)"
/></a>

	  <a href="#Collisions">
  <rect
    x="350"
    y="240"
    width="250"
    height="200"
    fill="rgba(0, 0, 255, 0)"
/></a>





	  <a href="#Gravity&Forces">
  <rect
	x="320"
	y="100"
	width="140"
	height="70"
	fill="rgba(0, 0, 255, 0)"
/>
	  </a>
	  <a href="#Gravity&Forces">
  <rect
	x="470"
	y="40"
	width="140"
	height="120"
	fill="rgba(0, 0, 255, 0)"
/></a>




	  <a href="#Light&Shadows">
  <rect
	x="690"
	y="20"
	width="190"
	height="100"
	fill="rgba(0, 0, 255, 0)"
/></a>
	  <a href="#Light&Shadows">
  <rect
	x="690"
	y="120"
	width="200"
	height="200"
	fill="rgba(0, 0, 255, 0)"
/></a>




	<a href="#Particle_Systems">
  <rect
	x="530"
	y="450"
	width="200"
	height="100"
	fill="rgba(0, 0, 255, 0)"
/></a>
<a href="#Particle_Systems">
  <rect
	x="700"
	y="350"
	width="200"
	height="200"
	fill="rgba(0, 0, 255, 0)"
/></a>

  <!-- Grid overlay -->
   <!--
<pattern
  id="grid"
  width="50"
  height="50"
  patternUnits="userSpaceOnUse"
>
  <path d="M 50 0 L 0 0 0 50" fill="none" stroke="#ccc" />
</pattern>

<rect
  width="100%"
  height="100%"
  fill="url(#grid)"
/>-->




</svg>

	
	
	
	

	</div>



<!--Rigid Bodies section begins here-->
	<section class="text_blocks" >
        <h2 id="Rigid_Bodies">Starre Körper</h2> 
        


    <h3>Was ist ein starrer Körper?</h3>
	<p>A <strong>starrer Körper</strong> ist ein Objekt in einem Spiel, das <strong>bewegt sich und reagiert auf Kräfte,</strong> Aber <strong>Lässt sich nicht biegen, dehnen oder verformen.</strong>
<p></p>
Mit anderen Worten:
<ul>
<li>Das Objekt behält seine Form</li>
<li>Der Abstand zwischen allen Punkten des Objekts bleibt gleich</li>
<li>Es verhält sich wie ein fester Gegenstand in der realen Welt.</li>
</ul>

Beispiele:
<ul>
<li>Eine Kiste fällt zu Boden</li>
<li>Ein Charakter, der gedrängt wird</li>
<li>Ein Ball, der von einer Wand abprallt</li>
</ul>
<p></p>

<h3>Warum starre Körper in Spielen wichtig sind</h3>
<p>Starre Körper sind die Grundlage von <strong>Bewegung und Interaktion.</strong></p>

Sie erlauben:
<ul>
<li>Schwerkraft (Fallen, Springen)</li>
<li>Kollisionen (Aufprall auf Wände, Böden, andere Objekte)</li>
<li>Kräfte (Schub, Explosionen)</li>
<li>Rotationen (Umkippen von Objekten)</li>
</ul>
Ohne starre Körper würden Objekte:
<ul>
<li>Bewegen Sie sich durch Wände</li>
<li>Ignorieren Sie die Schwerkraft</li>
<li>Fühlt sich „schwammig“ oder unecht an</li>
</ul>
<p></p>
<h3>Was ein starrer Körper üblicherweise enthält</h3>
<p>Ein starrer Körper ist nicht nur ein Modell. Er ist <strong>Daten + Regeln.</strong></p>

Gemeinsame Eigenschaften:
<ul>
<li><strong>Masse</strong> – wie schwer das Objekt ist</li>
<li><strong>Geschwindigkeit</strong> – wie schnell es sich bewegt</li>
<li><strong>Beschleunigung</strong> – wie sich die Geschwindigkeit ändert</li>
<li><strong>Rotationsgeschwindigkeit / Winkelgeschwindigkeit</strong> – wie es sich dreht</li>
<li><strong>Kräfte</strong> – Schwerkraft, Stöße, Impulse</li>
<li><strong>Kollisionsform</strong> – wie es mit anderen Objekten kollidiert</li>
</ul>
<p></p>
<h3>Statische, dynamische und kinematische starre Körper</h3>
Die meisten Game-Engines unterteilen starre Körper in verschiedene Typen:

<h4>Statische starre Körper</h4>
<ul>
<li>Nicht bewegen</li>
<li>Verwendungszweck: Böden, Wände, Gelände</li>
</ul>
<h4>Dynamische starre Körper</h4>
<ul>
<li>Vollständig von der Physik beeinflusst</li>
<li>Verwendet für: Spieler, Gegner, Kisten, Bälle</li>
</ul>
<h4>Kinematische starre Körper</h4>
<ul>
<li>Bewegt durch Code, nicht durch Physik</li>
<li>Sie kollidieren immer noch mit anderen Objekten.</li>
<li>Verwendungszweck: bewegliche Plattformen, Türen</li>
</ul>

<p></p>

<h3>Starre Körper vs. weiche Körper</h3>
<ul>
<li><strong>Starre Körper</strong> → feste, unveränderliche Form</li>
<li><strong>Weiche Körper</strong> → biegen, dehnen, verformen (Stoff, Gelee, Fleisch)</li>
</ul>
<p>Die meisten Spiele verwenden <strong>Starre Körper fast überall</strong> weil sie sind:</p>
<ul>
<li>Schneller kalkulieren</li>
<li>Leichter zu steuern</li>
<li>Vorhersehbarer</li>
</ul>
<p></p>
<h3>Starre Körper in Game-Engines</h3>
Nahezu jeder Motor verfügt über eingebaute starre Körper:
<ul>
<li><strong>Unity</strong> → Rigidbody</li>
<li><strong>Unreal Engine</strong> → Physics Body / Chaos Physics</li>
<li><strong>Godot</strong> → RigidBody3D</li>
<li><strong>Custom engines</strong> → physics loop + collision system</li>
</ul>
Der Motor übernimmt:
<ul>
<li>Physikalische Berechnungen</li>
<li>Kollisionsauflösung</li>
<li>Zeitschritte</li>
</ul>

<p>Sie definieren einfach <strong>wie sich Objekte verhalten sollten.</strong></p>
<p></p>

<h3>Warum dieses Thema wichtig ist</h3>
<p>Das Verständnis starrer Körper hilft Ihnen dabei:</p>
<ul>
<li>Sorge dafür, dass sich Bewegung befriedigend anfühlt.</li>
<li>Verhindern Sie Fehler wie Clipping oder Zittern.</li>
<li>Erschaffe glaubwürdige Welten</li>
<li>Beherrsche die Physik, anstatt gegen sie anzukämpfen.</li>
</ul>
<p>Starre Körper sind die <strong>Brücke zwischen Bild und Interaktion.	</strong></p>
		

	
	</section>
	
	



<!--Topic: Collisions-->
		<section class="text_blocks">
        <h2 id="Collisions">Kollisionen</h2> 
        
        
    
  <h3>Was ist eine Kollision?</h3>
<p>Eine <strong>Kollision</strong> tritt auf, wenn sich zwei Objekte in einem Spiel <strong>berühren oder überlappen</strong> und das Spiel darauf <strong>reagieren</strong> muss.</p>
Beispiele:
<ul>
<li>Ein Spieler prallt gegen eine Wand</li>
<li>Eine Kugel trifft einen Feind</li>
<li>Ein Ball, der auf dem Boden hüpft.</li>
</ul>
<p>Ohne Kollisionsbehandlung würden Objekte einfach <strong>einander durchdringen.</strong></p>
<p></p>
<h3>Collider (Kollisionsformen)</h3>

<p>Spiele berechnen Kollisionen üblicherweise nicht anhand detaillierter Modelle, das wäre zu langsam.<br>
Stattdessen verwenden sie <strong>Collider</strong>: vereinfachte Formen, die den physikalischen Raum eines Objekts darstellen.</p>

Gängige Collider-Formen:
<ul>
<li><strong>Box</strong> – Kisten, Gebäude</li>
<li><strong>Sphere</strong> – Kugeln, Spielfiguren</li>
<li><strong>Capsule</strong> – Spieler (flüssige Bewegung)</li>
<li><strong>Plane</strong> – Boden</li>
<li><strong>Mesh</strong> – komplexe Formen (sorgfältig einsetzen)</li>
</ul>
<p><strong>Einfachere Formen = bessere Leistung.</strong></p>
<p></p>
<h3>Kollisionserkennung vs. Kollisionsreaktion</h3>
Die Kollisionsbehandlung umfasst zwei Hauptschritte:

<h4>1. Kollisionserkennung</h4>
<ul>
<li>Prüft, ob sich zwei Objekte schneiden</li>
<li>Verwendet mathematische und räumliche Algorithmen</li>
<li>Wird in jedem Frame oder Physikschritt ausgeführt</li>
</ul>
<h4>2. Kollisionsreaktion</h4>
<ul>
<li>Entscheidet, was als Nächstes passiert</li>
<li>Bewegung stoppen</li>
<li>Entlang von Oberflächen gleiten</li>
<li>Erholen Sie sich</li>
<li>Lösen Sie ein Ereignis aus (Schaden, Ton, Punktestand)</li>
</ul>
<p>Die Erkennung fragt: <b>„Haben sie sich berührt?“</b> <br>
Antwort fragt: <b>„Was sollen wir dagegen tun?“</b></p>
<p></p>
<h3>Auslöser vs. physikalische Kollisionen</h3>
Nicht alle Kollisionen sind physischer Natur.

<h4>Physische Kollisionen</h4>
<ul>
	<li>Gegenstände schieben sich gegenseitig auseinander</li>
	<li>Verwendungszweck: Wände, Böden, Hindernisse</li>
</ul>

<h4>Auslöser</h4>
<ul>
<li>Überlappungen erkennen, aber die Bewegung nicht blockieren</li>
<li>Verwendet für:
<ul>
<li>Kontrollpunkte</li>
<li>Schadenszonen</li>
<li>Aufnahmepunkte</li>
<li>Bereichserkennung (KI-Bildverarbeitung, Schallreichweite)</li>
</ul></li>
</ul>

<p></p>
<h3>Ebenen und Kollisionsmasken</h3>
<p>Zur Verbesserung der Leistung und zur Steuerung des Verhaltens verwenden Spiele <strong>Layer</strong>. <br>
Beispiele:</p>
<ul>
	<li>Spieler</li>
	<li>Feind</li>
	<li>Umwelt</li>
	<li>Projektile</li>
</ul>
Sie können Regeln wie die folgenden definieren:
<ul>
<li>Spieler kollidiert mit der Umgebung</li>
<li>Projektile kollidieren mit Gegnern</li>
<li>Spieler ignoriert Spieler</li>
</ul>
Dadurch werden unnötige Kollisionsprüfungen vermieden und Fehler verhindert.

<p></p>

<h3>Kontinuierliche vs. diskrete Kollisionen</h3>
Schnell bewegte Objekte können Kollisionen vermeiden, wenn sie nicht korrekt gehandhabt werden.

<h4>Diskrete Kollision</h4>
<ul>
<li>Prüft die Positionen pro Frame</li>
<li>Schnelle Objekte können sich durch Wände „tunneln“.</li>
</ul>
<h4>Kontinuierliche Kollision</h4>
<ul>
<li>Sagt die Bewegung zwischen den Frames voraus.</li>
<li>Wird für Kugeln oder sehr schnelle Objekte verwendet.</li>
</ul>

<h4>Häufige Kollisionsprobleme</h4>
<ul>
<li><strong>Clipping</strong> – Objekt durchdringt ein anderes</li>
<li><strong>Jittering</strong> – Objekt vibriert auf Oberflächen</li>
<li><strong>Sticking</strong> – Objekt bleibt an Kanten hängen</li>
<li><strong>Tunneling</strong> – Schnelles Objekt verfehlt Kollisionen</li>
</ul>

Diese Probleme werden üblicherweise wie folgt gelöst:
<ul>
<li>Bessere Kollisionserkennung</li>
<li>Korrekte Physik-Einstellungen</li>
<li>Kontinuierliche Kollisionserkennung</li>
</ul>

<h3>Kollisionen in Spiel-Engines</h3>
Die meisten Engines handhaben Kollisionen automatisch:

<ul>
<li>Unity → Collider, OnCollision, OnTrigger</li>
<li>Unreal Engine → Kollisionskanäle und Reaktionen</li>
<li>Godot → CollisionShape, Signale</li>
</ul>
Sie konzentrieren sich auf:
<ul>
<li>Den richtigen Collider auswählen</li>
<li>Antworten definieren</li>
<li>Ereignisse behandeln</li>
</ul>
<p></p>
<h3>Warum Kollisionen so wichtig sind</h3>
Kollisionen definieren:
<ul>
<li>Wohin sich die Spieler bewegen können</li>
<li>Welche Objekte interagieren können</li>
<li>Wie real sich die Welt anfühlt</li>
</ul>

<p>Gutes Kollisionsdesign sorgt dafür, dass sich ein Spiel <strong>präzise, ​​reaktionsschnell und ausgereift anfühlt</strong>. Schlechte Kollisionen zerstören sofort die Immersion.</p>



	</section>
	
	





<!--Topic: Gravity & Forces-->
    	<section class="text_blocks">
        <h2 id="Gravity&Forces">Schwerkraft & Kräfte</h2> 
        
       
    <h3>Was ist Schwerkraft in Spielen?</h3>
<p><strong>Die Schwerkraft</strong> ist eine konstante Kraft, die Objekte <strong>nach unten</strong>zieht. <br>
In Spielen, die Schwerkraft:</p>
<ul>
<li>Lässt Objekte fallen</li>
<li>Verleiht Sprüngen Gewicht</li>
<li>Hält Spieler auf dem Boden</li>
<li>Definiert die Bedeutung von „oben“ und „unten“</li>
</ul>
Anders als im realen Leben ist die Schwerkraft in Spielen:
<ul>
	<li>Einstellbar</li>
	<li>Richtung</li>
	<li>Manchmal optional</li>
</ul>

Du kannst die Schwerkraft erzeugen:
<ul>
	<li>Besonders geeignet für schnelle Jump'n'Run-Spiele</li>
	<li>Weniger geeignet für schwammige Bewegungen</li>
	<li>Deaktiviert für Weltraum- oder Unterwasserszenen</li>
</ul>
<p></p>
<h3>Was ist eine Kraft?</h3>
<p>Eine <strong>Kraft</strong> ist alles, was <strong>die Bewegung eines Objekts verändert</strong>. <br>
Kräfte können:</p>
<ul>
<li>Bewegung starten</li>
<li>Bewegung stoppen</li>
<li>Richtung ändern</li>
<li>Rotation auslösen</li>
</ul>
Beispiele:
<ul>
<li>Spielereingaben (Gehen, Springen)</li>
<li>Wind, der Objekte bewegt</li>
<li>Explosionen</li>
<li>Die Schwerkraft selbst</li>
</ul>
<h3>Wie Kräfte auf starre Körper wirken</h3>
<p>Kräfte verändern nicht direkt die Position, sondern die <strong>Beschleunigung</strong>.
<br>
Grundgedanke:</p>
<ul>
<li>Kraft → Beschleunigung → Geschwindigkeit → Position</li>
</ul>

This is why:
<ul>
<li>Schwere Objekte beschleunigen langsamer.</li>
<li>Leichte Objekte reagieren schnell.</li>
<li>Masse ist wichtig.</li>
</ul>
<p></p>
<h3>Kontinuierliche Kräfte vs. Impulse</h3>
Es gibt zwei Hauptarten, Kräfte anzuwenden:

<h4>Kontinuierliche Kräfte</h4>
<ul>
	<li>Im Laufe der Zeit angewendet</li>
	<li>Beispiel:
	<ul>
		<li>Schwerkraft</li>
		<li>Motorschub</li>
		<li>Ständiger Wind</li>
	</ul></li>

</ul>Ergebnis: gleichmäßige, allmähliche Bewegung
<h4>Impulse</h4>
<ul>
	<li>Sofort angewendet</li>
	<li>Beispiel:
	<ul>
	<li>Springe</li>
		<li>Explosion</li>
		<li>Einschusswirkung</li>
	</ul></li>


</ul>Ergebnis: plötzliche Geschwindigkeitsänderung
<p></p>
<h3>Schwerkraft und Springen</h3>
Springen erfolgt üblicherweise durch:
<ul>
<li>Einen Aufwärtsimpuls geben</li>
<li>Die Schwerkraft zieht den Spieler wieder nach unten</li>
</ul> Ein gutes Sprungdesign hängt ab von:
<ul>
<li>Schwerkraft</li>
<li>Sprungimpuls</li>
<li>Fallgeschwindigkeit</li>
<li>Flugkontrolle</li>
</ul>
Deshalb fühlt sich das Springen in den verschiedenen Spielen ganz unterschiedlich an.
<p></p>
<h3>Richtungs- und benutzerdefinierte Schwerkraft</h3>
Die Schwerkraft muss nicht nach unten gerichtet sein.
<br>
Beispiele:
<ul>
<li>Planeten mit sphärischer Schwerkraft</li>
<li>Rotierende Raumstationen</li>
<li>Puzzlespiele mit wechselnder Schwerkraft</li>
<li>Schwerkraftfreie Umgebungen</li>
</ul>
<p>Viele Spiele behandeln die Schwerkraft einfach als einen weiteren Kraftvektor.</p>

<h3>Kraftgrenzen und Dämpfung</h3>
Um die physikalischen Gesetze stabil zu halten, verwenden Engines Grenzwerte:
<ul>
<li><strong>Widerstand/Dämpfung</strong> – Verlangsamt die Bewegung mit der Zeit</li>
<li><strong>Maximalgeschwindigkeit</strong> – Verhindert unendliche Geschwindigkeit</li>
<li><strong>Kraftbegrenzung</strong> – Sorgt für realistische Kräfte</li>
</ul>
<p></p>
Ohne diese:
<ul>
	<li>könnten Objekte endlos gleiten.</li>
	<li>könnten Geschwindigkeiten explosionsartig ansteigen.</li>
	<li>werden die Gesetze der Physik instabil.</li>
</ul>
<h3>Schwerkraft und Kräfte in Game-Engines</h3>
Beispiele:
<ul>
<li><strong>Unity</strong> → AddForce, ForceMode, Schwerkrafteinstellungen</li>
<li><strong>Unreal Engine</strong> → Kräfte, Impulse, Physikbeschränkungen</li>
<li><strong>Godot</strong> → Pro Physikschritt angewendete Kräfte</li>
</ul>
Die Software übernimmt die Berechnungen – Sie entscheiden:
<ul>
<li>Wann Kräfte anwenden</li>
<li>Wie stark sie sind</li>
<li>Wie sie interagieren</li>
</ul>

<h3>Warum Schwerkraft und Kräfte wichtig sind</h3>
Sie definieren:
<ul>
<li>Spielgefühl</li>
<li>Gewicht und Reaktionsfähigkeit</li>
<li>Realismus vs. Spielspaß – die richtige Balance</li>
</ul>
<p>Zwei Spiele können dieselben Modelle und Kollisionen verwenden,
aber unterschiedliche Schwerkraft- und Kraftwerte sorgen dafür, dass sie sich völlig unterschiedlich anfühlen.</p>





	</section>
	
	





<!--Topic: Light & Shadows-->
<section class="text_blocks">
        <h2 id="Light&Shadows">Licht & Schatten</h2> 
        

    
  <h3>Warum Licht in Spielen wichtig ist</h3>

<p>Licht definiert <strong>wie Spieler deine Welt sehen.</strong><br>
Gute Beleuchtung:</p>
<ul>
<li>Schafft Atmosphäre</li>
<li>Zeigt Tiefe und Form</li>
<li>Lenkt die Aufmerksamkeit des Spielers</li>
<li>Macht Umgebungen glaubwürdig</li>
</ul>
Ohne Beleuchtung wirken selbst hochwertige Modelle flach und leblos.
<p></p>
<h3>Was ist Licht in einer Game-Engine?</h3>

<p>In Spielen ist Licht eine <strong>mathematische Simulation</strong>, keine realen Photonen.
<br>Lichter beeinflussen:</p>
<ul>
	<li>Objektfarbe</li>
	<li>Helligkeit</li>
	<li>Kontrast</li>
	<li>Schattenrichtung</li>
</ul>
<p>Die meisten Engines berechnen die Beleuchtung <strong>pro Frame</strong> in Echtzeit.</p>
<p></p>
<h3>Gängige Lampenarten</h3>

<h4>Richtungslicht</h4>
<ul>
<li>Licht ohne sichtbare Quelle</li>
<li>Überall die gleiche Richtung</li>
<li>Verwendet für: Sonne oder Mond</li>
</ul>

<h4>Punktlicht</h4>
<ul>
<li>Sendet Licht von einem Punkt in alle Richtungen aus</li>
<li>Verwendung: Lampen, Fackeln, Explosionen</li>
</ul>

<h4>Spotlicht</h4>
<ul>
<li>Emittiert Licht kegelförmig</li>
<li>Verwendet für: Taschenlampen, Bühnenbeleuchtung, Scheinwerfer</li>
</ul>
<p></p>
<h3>Echtzeitbeleuchtung vs. voreingestellte Beleuchtung</h3>

<h4>Echtzeitbeleuchtung</h4>
<ul>
<li>Wird in jedem Frame neu berechnet</li>
<li>Lichter und Schatten können sich bewegen</li>
<li>Rechenintensiver</li>
<li>Wird für dynamische Objekte und Tageszeitsysteme verwendet</li>
</ul>

<h4>Gebackene Beleuchtung</h4>
<ul>
<li>Vorberechnet und gespeichert</li>
<li>Sehr schnell zur Laufzeit</li>
<li>Lichter können sich nicht bewegen</li>
<li>Für statische Umgebungen geeignet</li>
</ul>
Viele Spiele verwenden einen Hybridansatz.
<p></p>
<h3>Was sind Schatten?</h3>

<p>Schatten entstehen dort, wo Licht von einem Objekt blockiert wird.
<br>
Sie:</p>
<ul>
<li>Objektposition anzeigen</li>
<li>Tiefenwahrnehmung verbessern</li>
<li>Bewegungen lesbar machen</li>
</ul>
Ohne Schatten:
<ul>
<li>Objekte scheinen zu schweben</li>
<li>Entfernungen sind schwerer einzuschätzen</li>
</ul>
<p></p>
<h3>Arten von Schatten</h3>

<h4>Harte Schatten</h4>

<ul>
<li>Scharfe Kanten</li>

<li>Schnelle Renderzeit</li>

<li>Wirkt weniger realistisch</li>
</ul>

<h4>Weiche Schatten</h4>

<ul>
<li>Verschwommene Kanten</li>
<li>Realistischer</li>
<li>Rechenintensiver</li>
</ul>

<p></p>
<h3>Schattentechniken (vereinfacht)</h3>
<ul>
<li><strong>Schattenkarten</strong> – die gängigste Echtzeitmethode</li>
<li><strong>Blob-Schatten</strong> – künstliche Schatten unter den Figuren</li>
<li><strong>Vorberechnete Schatten</strong> – vorab berechnet, sehr ressourcenschonend</li>
</ul>
Spiele kombinieren oft verschiedene Techniken für eine gelungene Aufführung.
<p></p>
<h3>Beleuchtung als Gameplay-Werkzeug</h3>
<p>Beleuchtung ist nicht nur visuell, sie beeinflusst auch das Gameplay.

<br>Beispiele:</p>
<ul>
<li>Dunkle Bereiche verbergen Feinde</li>
<li>Helle Wege leiten den Spieler</li>
<li>Flackerndes Licht erzeugt Spannung</li>
<li>Schatten verraten Bewegungen</li>
</ul>
Viele Horror- und Schleichspiele setzen stark auf Beleuchtung.

<h3>Leistungsaspekte</h3>
Beleuchtung ist ressourcenintensiv.

Optimierungsmöglichkeiten:

<ul>
<li>Echtzeitbeleuchtung reduzieren</li>
<li>Schattenauflösung verringern</li>
<li>Nach Möglichkeit vordefinierte Beleuchtung verwenden</li>
<li>Schatten unwichtiger Objekte deaktivieren</li>
</ul>
Gute Beleuchtung basiert auf klugen Entscheidungen, nicht auf maximaler Qualität.


<h3>Licht & Schatten in Game-Engines</h3>
<ul>
<li>Unity → Lichttypen, Schatteneinstellungen, Light Baking</li>
<li>Unreal Engine → Dynamische Beleuchtung & Lumen-Beleuchtung</li>
<li>Godot → Lichter, Schatten, Lightmaps</li>
</ul>
Die Engine übernimmt das Rendering, Sie entscheiden:
<ul>
<li>Stimmung</li>
<li>Sichtbarkeit</li>
<li>Performance-Balance</li>
</ul>
<p></p>
<h3>Warum dieses Thema wichtig ist</h3>
Licht und Schatten:
<ul>
<li>Bestimmen Sie die Stimmung Ihres Spiels</li>
<li>Machen Sie Welten lesbar</li>
<li>Unterscheiden Sie Amateurprojekte von ausgereiften Spielen</li>
</ul>

Eine gelungene Beleuchtung kann einfache Geometrie fantastisch aussehen lassen.


	</section>





<!--Topic: Particle Systems-->
	<section class="text_blocks">
        <h2 id="Particle_Systems">Partikelsysteme</h2> 
        

    
    <h3>Was ist ein Teilchensystem?</h3>

<p>Ein <strong>Partikelsystem</strong> simuliert eine große Anzahl <strong>kleiner visueller Elemente</strong>, die als Partikel bezeichnet werden.
<br>
Jedes Partikel ist üblicherweise:</p>
<ul> 
	<li>Ein winziger Sprite oder ein Mesh</li>
	<li>Kurzlebig</li>
	<li>Leicht zu rendern</li>
</ul>
<p>Einzeln betrachtet sind sie einfach, aber zusammen erzeugen sie komplexe Effekte.
<br>
Beispiele:</p>
<ul>
	<li>Feuer</li>
	<li>Rauch</li>
	<li>Explosionen</li>
	<li>Funken</li>
	<li>Magische Effekte</li>
	<li>Regen, Schnee, Staub</li>
</ul>
<p></p>
<h3>Warum Spiele Partikelsysteme verwenden</h3> 
Partikelsysteme werden verwendet, weil sie:
<ul>
	<li>Dynamische Effekte kostengünstig erstellen</li>
	<li>Sind hochgradig anpassbar</li>
	<li>Reagieren optimal auf Gameplay-Ereignisse</li>
	<li>Wirkung und Feedback hinzufügen</li>
</ul>
<p>Ein einzelner Explosionseffekt kann aus <strong>Hunderten von Partikeln</strong> bestehen, die zusammenarbeiten.</p>
<p></p>
<h3>Wie Partikelsysteme funktionieren (vereinfacht)</h3>
Ein Teilchensystem besteht aus drei Hauptteilen:

<h4>1. Emission</h4>
<ul>
	<li>Wie viele Partikel werden erzeugt?</li>
	<li>Wann werden sie erzeugt (kontinuierlich oder stoßweise)?</li>
</ul>

<h4>2. Partikelverhalten</h4>
<ul>
	<li>Lebenslang</li>
	<li>Geschwindigkeit</li>
	<li>Richtung</li>
	<li>Größe</li>
	<li>Farbe</li>
	<li>Einfluss der Schwerkraft</li>
</ul>

<h4>3. Rendering</h4>
<ul>
<li>Wie Partikel auf dem Bildschirm aussehen</li>
<li>Sprite, Mesh, Glühen, Transparenz</li>
</ul>

Partikel werden ständig:
<ul>
<li>Erzeugt</li>
<li>Aktualisiert</li>
<li>Zerstört</li>
</ul>
<p></p>
<h3>Häufige Partikelverhalten</h3>
Partikel können:
<ul>
<li>Ein- oder Ausblenden</li>
<li>Wachsen oder schrumpfen</li>
<li>Ihre Farbe im Laufe der Zeit ändern</li>
<li>Von der Schwerkraft beeinflusst werden</li>
<li>Wind oder Turbulenzen folgen</li>
<li>Sich mit der Geschwindigkeit drehen oder dehnen</li>
</ul>
Diese kleinen Veränderungen erzeugen glaubwürdige Bewegung.
<p></p>
<h3>Lokaler Raum vs. Weltraum</h3>
<h4>Lokaler Raum</h4>
<ul>
<li>Partikel bewegen sich mit dem Objekt</li>
<li>Verwendet für: Flammen an einer Fackel, Motorabgase</li>
</ul>
<h4>Weltraum</h4>
<ul>
<li>Partikel bleiben an ihrem Entstehungsort.</li>
<li>Verwendet für: Explosionen, Rauchwolken.</li>
</ul>
Die Wahl des richtigen Raums ist wichtig für den Realismus.
<p></p>
<h3>Partikelsysteme und Physik</h3>
Partikel:
<ul>
<li>Ignorieren Kollisionen.</li>
<li>Erfahren einfache Schwerkraft.</li>
<li>Interagieren nicht physikalisch mit der Welt.</li>
</ul>
Dadurch bleiben sie schnell.
<p></p>
Einige Systeme ermöglichen:
<ul>
<li>Kollision mit der Umgebung</li>
<li>Abprallen oder Gleiten</li>
<li>Auslösen von Ereignissen</li>
</ul>
Aufgrund der Leistungskosten ist Vorsicht geboten.
<p></p>
<h3>Partikelsysteme als Feedback</h3>
Partikel übermitteln dem Spieler Informationen.
<br>
Beispiele:
<ul>
<li>Funken treffen → erfolgreicher Angriff</li>
<li>Staub → schnelle Bewegung</li>
<li>Leuchten → interaktives Objekt</li>
<li>Rauch → Schaden oder Gefahr</li>
</ul>
Gute Effekte verbessern die Klarheit, nicht nur die visuelle.
<p></p>
<h3>Leistungsaspekte</h3>
Partikelsysteme können bei übermäßiger Nutzung teuer sein.
<br>
Optimierungstipps:
<ul>
<li>Partikelanzahl begrenzen</li>
<li>Einfache Texturen verwenden</li>
<li>Lebensdauern kurz halten</li>
<li>Unnötige Kollisionen vermeiden</li>
<li>Effekte außerhalb des Bildschirms deaktivieren</li>
</ul>
Viele kleine Effekte können einen großen Effekt ausgleichen.

<h3>Partikelsysteme in Game-Engines</h3>
<ul>
	<li>Unity → Particle System component</li>
	<li>Unreal Engine → Niagara / Cascade</li>
	<li>Godot → GPUParticles / CPUParticles</li>
</ul>
<p>Moderne Engines lassen Partikel oft auf der <strong>GPU</strong> ausführen, um eine höhere Geschwindigkeit zu erreichen.</p>
<p></p>
<h3>Warum Teilchensysteme wichtig sind</h3>
Teilchensysteme:
<ul>
<li>Aktionen wirkungsvoll gestalten</li>
<li>Umgebungen lebendiger gestalten</li>
<li>Spielerfeedback verbessern</li>
<li>Visuelle Einschränkungen an anderer Stelle verbergen</li>
</ul>
Sie stellen eine der größten Verbesserungen von „funktioniert“ zu „fühlt sich großartig an“ dar.




	</section>









	<!--
	<section class="text_blocks">
        <h2>Game Loop</h2> 
        
        <p id="text_passage_one"> 
    
    If there is one pattern this book couldn’t live without, this is it. Game loops are the quintessential example of a “game programming pattern”. Almost every game has one, no two are exactly alike, and relatively few programs outside of games use them.

To see how they’re useful, let’s take a quick trip down memory lane. In the olden days of computer programming when everyone had beards, programs worked like your dishwasher. You dumped a load of code in, pushed a button, waited, and got results out. Done. These were batch mode programs — once the work was done, the program stopped.
 </p>

	</section>
-->




 <script src="../Java_Scripts/Header.js"></script>
	</body>
	
	
		
	
	
	
	
	
	
	
</html>