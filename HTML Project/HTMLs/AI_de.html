<!DOCTYPE html>
<html>
<!--The entire head and header part is identical to the starting page-->

	<head>
		<title> Spiele KI & Logik</title>
		<meta charset="utf-8">
		<link rel="stylesheet" href="../Style_Sheets/Info_Pages_Style_Sheet.css">
	</head>
	<body>
			<header id="Header_Wrapper">
		
		<div id="Head_Part"> <p id="title"> Spiele KI & Logik</p></div>
		
		
		

		<div id="Second_Head"> 
			<table id="table_header"> 
				<tr> <td class="menu_data" id="menu_button">
					<p id= "Menu_bar"> Menu</p>
						<div id="popup_menu">
        					<a href="Game_Development_Website_de.html">Zurück zum Start</a>
       						<a href="Basics_de.html">Die Basics</a>
       						<a href="Physics_de.html">Die Physik von Videospielen</a>
							<a href="Sources_de.html">Quellen</a>
   						 </div> 
					</td> 
				<td class="menu_data"> <a href="Sources_de.html">Quellen</a> </td> </tr>
			</table>
		</div>
		
				
		
		</header>
	
	<a href="#Placeholder">
  <button id="Back_To_Top">Hoch</button>
</a>

<a href="AI.html" id="Switch_Lang_Link">
 <img id="German_Flag" src="../Pictures/English_language.png" alt="Switch to German Icon">
  <p id="Switch_Lang_Label">switch to English</p>
</a>

<div id="Placeholder"></div>


<section class="text_blocks overview_section" id="text_block_one" >
        <h2></h2> 
        
        <p id="text_passage_one"> 
			<!--svg to make a field which you can interact with-->
 <svg
  viewBox="0 0 1000 600"
  width="100%"
  xmlns="http://www.w3.org/2000/svg"
>
  <!-- Background image -->
  <image
    href="../Pictures/Game_Ai_Preview.png"
    x="0"
    y="0"
    width="1000"
    height="600"
  />

  <a href="#Pathfinding">
  <rect
    x="120"
    y="75"
    width="230"
    height="50"
    fill="rgba(0, 0, 255, 0)"
	/>
<a href="#Pathfinding">
  <rect
    x="75"
    y="150"
    width="260"
    height="250"
    fill="rgba(0, 0, 255, 0)"
	/>
	  <a href="#Pathfinding">
  <rect
	x="320"
	y="130"
	width="80"
	height="100"
	fill="rgba(0, 0, 255, 0)"
/>
<a href="#Pathfinding">
  <rect
    x="75"
    y="340"
    width="350"
    height="250"
    fill="rgba(0, 0, 255, 0)"
	/>






	  <a href="#Enemy_Behaviours">
  <rect
    x="410"
    y="50"
    width="250"
    height="200"
    fill="rgba(0, 0, 255, 0)"
/>

	  <a href="#Enemy_Behaviours">
  <rect
    x="340"
    y="240"
    width="300"
    height="100"
    fill="rgba(0, 0, 255, 0)"
/>
<a href="#Enemy_Behaviours">
  <rect
	x="425"
	y="340"
	width="200"
	height="100"
	fill="rgba(0, 0, 255, 0)"
/>






	  <a href="#Decision_Trees">
  <rect
	x="700"
	y="35"
	width="200"
	height="200"
	fill="rgba(0, 0, 255, 0)"
	/>







	
<a href="#State_Machines">
  <rect
	x="650"
	y="250"
	width="250"
	height="300"
	fill="rgba(0, 0, 255, 0)"
/>

  <!-- Grid overlay -->
<!--
<pattern
  id="grid"
  width="50"
  height="50"
  patternUnits="userSpaceOnUse"
>
  <path d="M 50 0 L 0 0 0 50" fill="none" stroke="#ccc" />
</pattern>

<rect
  width="100%"
  height="100%"
  fill="url(#grid)"
/>-->




</svg>

	
	
	
		</p>

	</section>




	<section class="text_blocks" id="text_block_one">
        <h2 id="Pathfinding">Pathfinding</h2> 
        
        <p id="text_passage_one"> 
    
  <h3>Was ist Pfadfindung?</h3>
<p><strong>Pfadfindung</strong> ist der Prozess, einen <strong>Weg von einem Punkt zu einem anderen</strong> zu finden und dabei Hindernisse zu vermeiden.
<br>
In Spielen wird die Pfadfindung für Folgendes verwendet:</p>
<ul>
<li>Feinde, die den Spieler verfolgen</li>
<li>NPCs, die durch Städte laufen</li>
<li>Einheiten, die sich in Strategiespielen bewegen</li>
<li>Tiere, die die Umgebung erkunden</li>
</ul>
Ohne Pfadfindung würde die KI entweder:
<ul>
<li>Gehen Sie in geraden Linien</li>
<li>Bleiben Sie an Wänden hängen</li>
<li>Fühlen Sie sich unintelligent</li>
</ul>
<p></p>
<h3>Das Kernproblem</h3>
Given:
<ul>
<li>Eine <strong>Startposition</strong></li>
<li>Eine <strong>Zielposition</strong></li>
<li>Eine Welt mit <strong>Hindernissen</strong></li>
</ul>
Ziel ist es, Folgendes zu finden:
<ul>
<li>Der <strong>beste Weg</strong></li>
<li>Mit dem <strong>kostengünstigsten</strong></li>
<li>In einer <strong>angemessenen Zeitspanne</strong></li>
</ul>
„Beste“ bedeutet in der Regel kürzeste, sicherste oder schnellste Lösung.
<p></p>

<h3>Die Welt darstellen</h3>
<p>Die KI sieht die Welt nicht so wie die Spieler.

<br>Stattdessen verwendet sie vereinfachte Daten:</p>

<h4>Rasterbasiert</h4>
<ul>
<li>Die Welt ist in Kacheln unterteilt</li>
<li>Jede Kachel ist begehbar oder blockiert</li>
<li>Häufig in 2D-Spielen und Strategiespielen</li>
</ul>

<h4>Node Diagramme</h4>
<ul>
<li>Wichtige Punkte, die durch Kanten verbunden sind</li>
<li>Wird in komplexen oder handgefertigten Levels verwendet</li>
</ul>

<h4>Navigationsnetz (NavMesh)</h4>
<ul>
<li>Begehbare Flächen zu Polygonen verschmolzen</li>
<li>Häufig in 3D-Spielen</li>
<li>Sehr effizient für flüssige Bewegungen</li>
</ul>
<p></p>
<h3>Der A*-Algorithmus (A-Stern)</h3>
<p>Der am häufigsten verwendete Pfadfindungsalgorithmus in Spielen ist <strong>A*.</strong> <br>
A* funktioniert folgendermaßen:</p>
<ul>
<li>Mögliche Wege erkunden</li>
<li>Bewertung dieser Wege anhand folgender Kriterien:</li>
<ul>
<li>Bereits zurückgelegte Strecke</li>
<li>Geschätzte Entfernung zum Ziel</li>
</ul>
<li>Immer den vielversprechendsten Weg wählen</li>
</ul>

Es ist beliebt, weil es Folgendes ist:
<ul>
<li>Schnell</li>
<li>Genau</li>
<li>Vorhersagbar</li>
</ul>
<p></p>
<h3>Kosten und Gewichte</h3>
Nicht alle Wege sind gleich.
<p></p>
Spiele ordnen Bereichen Kosten zu:
<ul>
<li>Straßen → niedrige Kosten</li>
<li>Schlamm → hohe Kosten</li>
<li>Gefahrenzonen → sehr hohe Kosten</li>
</ul>

This allows AI to:
<ul>
<li>Bevorzugen Sie sicherere Routen</li>
<li>Vermeiden Sie Gefahren</li>
<li>Fühlen Sie sich klüger</li>
</ul>
<p></p>
<h3>Dynamische Hindernisse</h3>
In realen Spielen verändert sich die Welt:
<ul>
<li>Türen öffnen und schließen</li>
<li>Objekte bewegen sich</li>
<li>Andere Charaktere versperren Wege</li>
</ul>
Wegfindungssysteme lösen dies folgendermaßen:
<ul>
<li>Pfade werden neu berechnet</li>
<li>Vermeidungsverhalten wird angewendet</li>
<li>Auf einfaches Lenkverhalten wird zurückgegriffen</li>
</ul>
<p></p>
<h3>Wegfindung vs. Bewegung</h3>
Wegfindung:
<ul><li>Entscheidet, wohin es gehen soll</li></ul>

Bewegung:
<ul><li>Entscheidet, wie er dorthin umziehen soll.</li></ul>
Eine KI kann:
<ul>
<li>Einmal einen Pfad berechnen</li>
<li>Diesem Pfad mithilfe physikalischer Gesetze oder durch Lenkung folgen</li>
<li>Bei Änderungen neu berechnen</li>
</ul>
Diese Systeme arbeiten zusammen, sind aber voneinander getrennt.
<p></p>
<h3>Pfadfindung in Game-Engines</h3>
<ul>
<li><strong>Unity</strong> → NavMesh & NavMeshAgent</li>
<li><strong>Unreal Engine</strong> → Navigationssystem</li>
<li><strong>Godot</strong> → NavigationServer / NavigationRegion</li>
</ul>

Motoren normalerweise:
<ul>
<li>Navigationsdaten generieren</li>
<li>Pfadabfragen verarbeiten</li>
<li>Bewegungshilfen bereitstellen</li>
</ul>
<p></p>
<h3>Warum Wegfindung wichtig ist</h3>
Gute Wegfindung:
<ul>
<li>Lässt KI intelligent wirken</li>
<li>Verhindert lästige Fehler</li>
<li>Unterstützt komplexe Level</li>
<li>Skaliert auf viele Agenten</li>
</ul>
Schlechte Wegfindung zerstört sofort die Immersion.

</p>

	</section>
	
	






		<section class="text_blocks">
        <h2 id="Enemy_Behaviours">Feindliches Verhalten</h2> 
        
        <p id="text_passage_one"> 
    
   <h3>Was sind feindliche Verhaltensweisen?</h3>

<p>Das Verhalten der Gegner definiert, wie sie im Spiel agieren, reagieren und Entscheidungen treffen.
<br>
Sie kontrollieren:</p>
<ul>
<li>Wenn ein Feind angreift</li>
<li>Wie es sich bewegt</li>
<li>Wie es auf den Spieler reagiert</li>
<li>Wann es sich zurückzieht oder seine Strategie ändert</li>
</ul>
Gutes Benehmen schafft Feinde:
<ul>
<li>Vorhersagbar genug, um daraus zu lernen</li>
<li>Unvorhersehbar genug, um interessant zu bleiben</li>
</ul>
<p></p>
<h3>Kernverhaltenszustände</h3>
<p>Die meisten feindlichen KIs basieren auf Zuständen.
<br>Gängige Zustände sind:</p>
<ul>
<li><strong>Leerlauf</strong> – Steht still, patrouilliert</li>
<li><strong>Patrouille</strong> – Bewegt sich auf einem Pfad</li>
<li><strong>Alarm</strong> – Etwas Verdächtiges ist passiert</li>
<li><strong>Verfolgung</strong> – Spieler entdeckt</li>
<li><strong>Angriff</strong> – Spieler wird angegriffen</li>
<li><strong>Suche</strong> – Spieler verloren</li>
<li><strong>Rückzug/Flucht</strong> – Niedrige Gesundheit oder Gefahr</li>
</ul>
Gegner wechseln je nach Bedingungen zwischen verschiedenen Zuständen.
<p></p>
<h3>Endliche Zustandsautomaten (FSM)</h3>

<p>Die am häufigsten verwendete Struktur für feindliches Verhalten ist die <strong>endliche Zustandsmaschine</strong>.<br>
So funktioniert es:</p>
<ul>
<li>Der Feind befindet sich immer in einem Zustand</li>
<li>Bedingungen lösen Übergänge aus</li>
<li>Jeder Staat hat eine klare Logik.</li>
</ul>

Beispiel:
<ul>
<li>Spieler gesehen → Patrouille → Verfolgung</li>
<li>Spieler in Reichweite → Verfolgung → Angriff</li>
<li>Spieler verloren → Verfolgung → Suche</li>
</ul>

FSMs sind:
<ul>
  <li>Leicht verständlich</li>
  <li>Leicht zu debuggen</li>
  <li>Sehr verbreitet in Spielen</li>
</ul>
<p></p>
<h3>Wahrnehmung: Wie Gegner den Spieler „spüren“</h3>
<p>Gegner benötigen Möglichkeiten, den Spieler zu entdecken.
Allgemeine Sinne:</p>
<ul>
<li><strong>Sehvermögen</strong> – Kegel- oder Radiusprüfung</li>
<li><strong>Hörvermögen</strong> – Reaktion auf Geräusche</li>
<li><strong>Nähe</strong> – distanzbasierte Auslöser</li>
<li><strong>Sichtlinie</strong> – Raycasts</li>
</ul>
Die Wahrnehmung bestimmt, wann sich Verhaltensweisen ändern.
<p></p>
<h3>Aggression und Schwierigkeiten</h3> 
Das Verhalten ändert sich oft bei:
<ul>
<li>Gesundheit</li>
<li>Distanz</li>
<li>Spieleraktionen</li>
<li>Schwierigkeitsgrad</li>
</ul>
Beispiele:
<ul>
<li>Niedrige Gesundheit → defensives Verhalten</li>
<li>Hoher Schwierigkeitsgrad → schnellere Reaktionen</li>
<li>Spieler versteckt sich → Suchverhalten</li>
</ul>
Dadurch entstehen dynamische Begegnungen.
<p></p>
<h3>Gruppen- und koordiniertes Verhalten</h3>
<p>Feinde handeln nicht immer allein.<br>
Gruppenverhalten umfasst:</p>
<ul>
<li>Um Hilfe rufen</li>
<li>Den Spieler flankieren</li>
<li>Abwechselnd angreifen</li>
<li>Positionen halten</li>
</ul>
Selbst einfache Koordination lässt die KI intelligenter erscheinen.
<p></p>
<h3>Vorgegebene vs. dynamische Verhaltensweisen</h3>

<h4>Vorgegebene Verhaltensweisen</h4>
<ul>
<li>Vordefinierte Aktionen</li>
<li>Wird für Bosse oder Story-Momente verwendet</li>
</ul>

<h4>Dynamische Verhaltensweisen</h4>
<ul>
<li>Reagiert auf den Spielzustand</li>
<li>Wird für normale Gegner verwendet</li>
</ul>
Die meisten Spiele kombinieren beides.
<p></p>
<h3>Feindverhalten in Spiel-Engines</h3>
<ul>
<li>Unity → Zustandsautomaten, Animatoren, Skripte</li>
<li>Unreal Engine → Verhaltensbäume, KI-Controller</li>
<li>Godot → Zustandsskripte, Signale</li>
</ul>
Motoren liefern Werkzeuge, aber:
<ul>
<li>Designentscheidungen definieren die Verhaltensqualität</li>
</ul>
<p></p>
<h3>Häufige Fehler der feindlichen KI</h3>
<ul>
<li>Feinde reagieren sofort (ohne Verzögerung)</li>
<li>Perfektes Zielen oder Verfolgen</li>
<li>Keine Abklingzeiten</li>
<li>No readable patterns</li>
</ul>
Gutes Gegnerdesign beinhaltet:
<ul>
<li>Angriffe vorhersehbar</li>
<li>Reaktionszeit</li>
<li>Fehler</li>
</ul>

<h3>Warum das Verhalten des Gegners wichtig ist</h3>
Das Verhalten des Gegners definiert:
<ul>
<li>Herausforderung</li>
<li>Tempo</li>
<li>Spaßfaktor</li>
</ul>
<p>
Spieler mögen die einfache Grafik verzeihen, <br>
aber schlechtes Gegnerverhalten ist unvergesslich (und zwar im negativen Sinne).</p>
	
	
	
	
	
	
		</p>

	</section>
	
	


	<section class="text_blocks">
        <h2 id="Decision_Trees">Entscheidungsbäume</h2> 
        
        <p id="text_passage_one"> 
    
<h3>Was ist ein Entscheidungsbaum?</h3>
<p>Ein <strong>Entscheidungsbaum</strong> ist eine strukturierte Methode für KI, um <strong>auf Grundlage von Bedingungen die zu ergreifende Aktion auszuwählen</strong>.
<br>Er funktioniert wie das Stellen von Fragen:</p>
<ul>
<li>Kann ich den Spieler sehen?</li>
<li>Ist der Spieler in Reichweite?</li>
<li>Ist meine Gesundheit niedrig?</li>
</ul>
Anhand der Antworten wählt die KI eine Aktion aus.
<p></p>
<h3>Wie Entscheidungsbäume funktionieren</h3> 
Ein Entscheidungsbaum besteht aus Knoten.
<h4>Entscheidungsknoten</h4>
<ul>
<li>Stelle eine Ja/Nein-Frage</li>
<li>Beispiel: Ist der Spieler sichtbar?</li>
</ul>
<h4>Aktionsknoten</h4>
<ul>
<li>Führe eine Aktion aus</li>
<li>Beispiel: Angreifen, Verfolgen, Patrouillieren</li>
</ul>
Die KI beginnt ganz oben und:
<ul>
<li>Prüft Bedingungen</li>
<li>Bewegt sich im Baum nach unten</li>
<li>Stoppt bei der ersten gültigen Aktion</li>
</ul>
<p></p>
<h3>Einfaches Beispiel</h3>
Logikablauf:
<ul>
<li>Wenn Spieler sichtbar ist → Wenn Spieler in Reichweite ist → Angriff → Sonst → Verfolgung</li>
<li>Sonst → Patrouille</li>
Diese Struktur ist leicht verständlich und einfach zu debuggen.
</ul>
<p></p>
<h3>Entscheidungsbäume vs. endliche Automaten</h3>
Beides sind gängige KI-Werkzeuge, aber sie lösen etwas unterschiedliche Probleme.

<h4>Endliche Zustandsautomaten (FSM)</h4>
<ul>
<li>Der Feind befindet sich jeweils nur in einem Zustand.</li>
<li>Gut geeignet für klar getrennte Verhaltensweisen</li>
</ul>
<h4>Entscheidungsbäume</h4>
<ul>
<li>Fokus auf die Auswahl von Aktionen</li>
<li>Besser für verschachtelte Bedingungen</li>
<li>Einfacher mit neuen Regeln erweiterbar</li>
</ul>
<p>Viele Spiele <strong>kombinieren beides</strong>.</p>
<p></p>
<h3>Tiefe und Priorität</h3>
Die Reihenfolge der Entscheidungen ist wichtig.
<ul>
<li>Höhere Zweige = höhere Priorität</li>
<li>Notfallmaßnahmen (niedrige Gesundheit, Gefahr) werden zuerst geprüft</li>
<li>Weniger wichtige Verhaltensweisen werden später überprüft</li>
</ul>
Dies verhindert seltsames Verhalten, wie zum Beispiel Angriffe im Sterben.
<p></p>
<h3>Vorteile von Entscheidungsbäumen</h3>
<ul>
<li>Leicht verständlich</li>
<li>Vorhersehbares Verhalten</li>
<li>Gute Prioritätenkontrolle</li>
<li>Visualisierbar (ideal für Designer)</li>
</ul>
<p></p>
<h3>Einschränkungen</h3>
<ul>
<li>Bäume können sehr groß werden</li>
<li>Komplexe Logik ist schwer zu handhaben</li>
<li>Änderungen erfordern möglicherweise eine Umstrukturierung</li>
</ul>
Bei großen Projekten führt dies zu Folgendem:
<ul>
<li><strong>Verhaltensbäume</strong></li>
<li><strong>Nutzen-KI</strong></li>
</ul>
<p></p>
<h3>Entscheidungsbäume in der Praxis</h3>
Verwendet für:
<ul>
<li>Einfache Gegner</li>
<li>Reaktionen von NPCs</li>
<li>KI der Begleiter</li>
<li>Auswahl der Bossphase</li>
</ul>
Sie sind besonders nützlich, wenn das Verhalten für die Spieler klar und nachvollziehbar sein muss.

<h3>Entscheidungsbäume in Game-Engines</h3>
<ul>
<li><strong>Unity</strong> → Benutzerdefinierte Skripte, visuelle Werkzeuge</li>
<li><strong>Unreal Engine</strong> → Verhaltensbäume (erweiterte Form)</li>
<li><strong>Godot</strong> → Skriptbasierte Logikbäume</li>
</ul>
Manche Engines bieten visuelle Editoren; andere setzen auf Code.

<h3>Warum Entscheidungsbäume wichtig sind</h3>
Entscheidungsbäume helfen KI:
<ul>
<li>Treffen Sie logische Entscheidungen</li>
<li>Reagieren Sie auf Spieleraktionen</li>
<li>Bleiben Sie verständlich und kontrollierbar</li>
</ul>
Sie stellen einen großen Schritt von „skriptbasierten Feinden“ hin zu reaktionsfähiger KI dar.
</p>

	</section>




	<section class="text_blocks">
        <h2 id="State_Machines">Zustandsmaschinen</h2> 
        
        <p id="text_passage_one"> 
<h3>Was ist ein Zustandsautomat?</h3>

<p>Ein <strong>Zustandsautomat</strong> beschreibt das Verhalten als eine Menge von <strong>unterschiedlichen Zuständen</strong>, wobei sich eine Entität jeweils nur in <strong>einem Zustand</strong> befinden kann.

Jeder Stand:</p>
<ul>
<li>Hat einen klaren Zweck</li>
<li>Steuert das Verhalten der Entität</li>
<li>Definiert, wann sie in einen anderen Zustand wechseln kann</li>
</ul>

Betrachten Sie es so:
<em>„Was mache ich gerade?“</em>
<p></p>
<h3>Gemeinsame Zustände in Spielen</h3>
Typische Zustände sind:
<ul>
<li>Leerlauf</li>
<li>Bewegen / Patrouillieren</li>
<li>Verfolgen</li>
<li>Angriff</li>
<li>Verteidigen</li>
<li>Erfroren</li>
<li>Tot</li>
</ul>
Nur eine dieser Funktionen ist jeweils aktiv.
<p></p>
<h3>Zustandsübergänge</h3>
<p>Ein <strong>Übergang</strong> ist eine Regel, die die KI von einem Zustand in einen anderen überführt.
Beispiele:</p>
<ul>
<li>Spieler entdeckt → Leerlauf → Verfolgung</li>
<li>Spieler in Reichweite → Verfolgung → Angriff</li>
<li>Niedrige Gesundheit → Angriff → Rückzug</li>
<li>Null Gesundheit → Beliebig → Tot</li>
</ul>
Übergänge werden üblicherweise ausgelöst durch:
<ul>
<li>Bedingungen</li>
<li>Ereignisse</li>
<li>Timer</li>
</ul>
<p></p>
<h3>Was geschieht innerhalb eines Zustands?</h3> 
Jeder Zustand enthält üblicherweise:
<ul>
<li>Eintrittslogik – was passiert beim Start des Zustands?</li>
<li>Aktualisierungslogik – was passiert in jedem Frame?</li>
<li>Ausgangslogik – Aufräumarbeiten vor dem Verlassen des Zustands</li>
</ul>
Dies erhält das Verhalten:
<ul>
<li>Organisiert</li>
<li>Vorhersagbar</li>
<li> und Leicht zu debuggen</li>
</ul>
zu sein
<p></p>
<h3>Endliche Zustandsautomaten (FSM)</h3>
Die meisten Spielzustandsautomaten sind endlich, was bedeutet:
<ul>
<li>Eine feste Anzahl von Zuständen</li>
<li>Klar definierte Übergänge</li>
</ul>
FSMs sind:
<ul>
<li>Einfach</li>
<li>Zuverlässig</li>
<li>Weit verbreitet</li>
</ul>
Sie eignen sich ideal für:
<ul>
<li>Feinde</li>
<li>NPCs</li>
<li>Spielobjekte</li>
<li>UI-Fluss</li>
<li>Spielerzustände (Springen, Fallen, Angreifen)</li>
</ul>
<p></p>
<h3>Zustandsautomaten jenseits der KI</h3>
<p>Zustandsautomaten sind nicht nur für Feinde da.
<br>Sie werden verwendet für:</p>
<ul>
<li>Spielerbewegungszustände</li>
<li>Animationssysteme</li>
<li>Spielablauf (Menüs, Gameplay, Pause)</li>
<li>Bossphasen</li>
</ul>
Sobald man sie verstanden hat, sieht man sie überall.
<p></p>
<h3>Zustandsautomaten vs. Entscheidungsbäume</h3>
<ul>
<li><strong>Zustandsautomaten</strong> → Was mache ich gerade?</li>
<li><strong>Entscheidungsbäume</strong> → Was soll ich als Nächstes tun?</li>
</ul>
Viele Spiele verwenden:
<ul>
<li>Entscheidungsbäume zur <strong>Zustandsauswahl</strong></li>
<li>Zustandsautomaten zur <strong>Ausführung des Verhaltens</strong></li>
</ul>
Diese Kombination ist kraftvoll und sauber.
<p></p>
<h3>Häufige Fehler</h3>
<ul>
<li>Zu viele Zustände</li>
<li>Zu viele Zustände</li>
<li>Übergänge sind unübersichtlich</li>
<li>Fehlende Ausweichzustände</li>
</ul>
Gute Zustandsautomaten sind:
<ul>
<li>Einfach</li>
<li>Konzentriert</li>
<li>Lesbar</li>
</ul>

<h3>Warum Zustandsautomaten ein perfektes Abschlussthema sind</h3>
Zustandsautomaten:
<ul>
<li>Bewegung, KI, Animation und Logik miteinander verbinden</li>
<li>Klare Struktur vermitteln</li>
<li>Von einfachen Gegnern zu komplexen Systemen skalieren</li>
</ul>
Wenn Sie Zustandsautomaten verstehen, können Sie mit folgendem Schritt fortfahren:
<p>
"Wie funktioniert das?" zu „Wie sollte sich das anfühlen?“
</p>
</p>

	</section>
    
	
	 <script src="../Java_Scripts/Header.js"></script>
	</body>
	
	
		
	
	
	
	
	
	
	
</html>