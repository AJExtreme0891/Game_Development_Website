<!DOCTYPE html>
<html>

<!--The entire head and header part is identical to the starting page-->
	<head>
		<title> The Phyics of Videogames </title>
		<meta charset="utf-8">
		<link rel="stylesheet" href="../Style_Sheets/Info_Pages_Style_Sheet.css">
	</head>
	<body>
			<header id="Header_Wrapper">
		
		<div id="Head_Part"> <p id="title"> The Phyics of Videogames</p></div>
		
		
		

		<div id="Second_Head"> 
			<table id="table_header"> 
				<tr> <td class="menu_data" id="menu_button">
					<p id= "Menu_bar"> Menu</p>
						<div id="popup_menu">
        					<a href="Game_Development_Website.html">Back to Start</a>
       						<a href="Basics.html">The Basics</a>
       						<a href="AI.html">Game AI & Logic</a>
							<a href="Sources.html">Sources</a>
   						 </div> 
					</td> 
				<td class="menu_data"> <a href="Sources.html">Sources</a> </td> </tr>
			</table>
		</div>
		
				
		
		</header>
	<!--Button to go back to the top-->
		<a href="#Placeholder">
  <button id="Back_To_Top">Back to Top</button>
</a>

<a href="Physics_de.html" id="Switch_Lang_Link">
 <img id="German_Flag" src="../Pictures/Flag_of_Germany.png" alt="Switch to German Icon">
  <p id="Switch_Lang_Label">wechsle zu Deutsch</p>
</a>


<!--invisible ELement meant to be a target for scrolling to the top quicker -->
<div id="Placeholder"></div>
	<!--The content of the page starts here-->
		<!--Each section is a different block of text with a heading-->
		
		

<section class="text_blocks overview_section" id="text_block_one" >
        <h2></h2> 
        
        <p id="text_passage_one"> 
			<!--svg to make a field which you can interact with-->
 <svg
  viewBox="0 0 1000 600"
  width="100%"
  xmlns="http://www.w3.org/2000/svg"
>
  <!-- Background image -->
  <image
    href="../Pictures/Preview_Physics.png"
    x="0"
    y="0"
    width="1000"
    height="600"
  />

  <a href="#Rigid_Bodies">
  <rect
    x="120"
    y="50"
    width="150"
    height="100"
    fill="rgba(0, 0, 255, 0)"
	/>
<a href="#Rigid_Bodies">
  <rect
    x="50"
    y="150"
    width="270"
    height="280"
    fill="rgba(0, 0, 255, 0)"
	/>



	  <a href="#Collisions">
  <rect
    x="370"
    y="170"
    width="225"
    height="50"
    fill="rgba(0, 0, 255, 0)"
/>

	  <a href="#Collisions">
  <rect
    x="350"
    y="240"
    width="250"
    height="200"
    fill="rgba(0, 0, 255, 0)"
/>





	  <a href="#Gravity&Forces">
  <rect
	x="320"
	y="100"
	width="140"
	height="70"
	fill="rgba(0, 0, 255, 0)"
/>

	  <a href="#Gravity&Forces">
  <rect
	x="470"
	y="40"
	width="140"
	height="120"
	fill="rgba(0, 0, 255, 0)"
/>




	  <a href="#Light&Shadows">
  <rect
	x="690"
	y="20"
	width="190"
	height="100"
	fill="rgba(0, 0, 255, 0)"
/>
	  <a href="#Light&Shadows">
  <rect
	x="690"
	y="120"
	width="200"
	height="200"
	fill="rgba(0, 0, 255, 0)"
/>




	<a href="#Particle_Systems">
  <rect
	x="530"
	y="450"
	width="200"
	height="100"
	fill="rgba(0, 0, 255, 0)"
/>
<a href="#Particle_Systems">
  <rect
	x="700"
	y="350"
	width="200"
	height="200"
	fill="rgba(0, 0, 255, 0)"
/>

  <!-- Grid overlay -->
   <!--
<pattern
  id="grid"
  width="50"
  height="50"
  patternUnits="userSpaceOnUse"
>
  <path d="M 50 0 L 0 0 0 50" fill="none" stroke="#ccc" />
</pattern>

<rect
  width="100%"
  height="100%"
  fill="url(#grid)"
/>-->




</svg>

	
	
	
		</p>

	</section>



<!--Rigid Bodies section begins here-->
	<section class="text_blocks" >
        <h2 id="Rigid_Bodies">Rigid Bodies</h2> 
        
        <p id="text_passage_one"> 

    <h3>What is a Rigid Body?</h3>
	<p>A <strong>rigid body</strong> is an object in a game that <strong>moves and reacts to forces</strong>, but <strong>does not bend, stretch, or deform.</strong>
<p></p>
In other words:
<ul>
<li>The object keeps its shape</li>
<li>The distance between all points of the object stays the same</li>
<li>It behaves like a solid object in the real world</li>
</ul>

Examples:
<ul>
<li>A crate falling to the ground</li>
<li>A character being pushed</li>
<li>A ball bouncing off a wall</li>
</ul>
<p></p>

<h3>Why Rigid Bodies Matter in Games</h3>
<p>Rigid bodies are the foundation of <strong>movement and interaction.</strong></p>

They allow:
<ul>
<li>Gravity (falling, jumping)</li>
<li>Collisions (hitting walls, floors, other objects)</li>
<li>Forces (pushing, explosions)</li>
<li>Rotations (objects tipping over)</li>
</ul>
Without rigid bodies, objects would:
<ul>
<li>Move through walls</li>
<li>Ignore gravity</li>
<li>Feel “floaty” or fake</li>
</ul>
<p></p>
<h3>What a Rigid Body Usually Contains</h3>
<p>A rigid body isn’t just a model. It’s <strong>data + rules.</strong></p>

Common properties:
<ul>
<li><strong>Mass</strong> – how heavy the object is</li>
<li><strong>Velocity</strong> – how fast it moves</li>
<li><strong>Acceleration</strong> – how velocity changes</li>
<li><strong>Rotation / Angular velocity</strong> – how it spins</li>
<li><strong>Forces</strong> – gravity, pushes, impulses</li>
<li><strong>Collision shape</strong> – how it collides with other objects</li>
</ul>
<p></p>
<h3>Static, Dynamic, and Kinematic Rigid Bodies</h3>
Most game engines split rigid bodies into types:

<h4>Static Rigid Bodies</h4>
<ul>
<li>Do not move</li>
<li>Used for: floors, walls, terrain</li>
</ul>
<h4>Dynamic Rigid Bodies</h4>
<ul>
<li>Fully affected by physics</li>
<li>Used for: players, enemies, crates, balls</li>
</ul>
<h4>Kinematic Rigid Bodies</h4>
<ul>
<li>Moved by code, not physics</li>
<li>Still collide with other objects</li>
<li>Used for: moving platforms, doors</li>
</ul>

<p></p>

<h3>Rigid Bodies vs Soft Bodies</h3>
<ul>
<li><strong>Rigid bodies</strong> → solid, unchanging shape</li>
<li><strong>Soft bodies</strong> → bend, stretch, deform (cloth, jelly, flesh)</li>
</ul>
<p>Most games use <strong>rigid bodies almost everywhere</strong> because they are:</p>
<ul>
<li>Faster to calculate</li>
<li>Easier to control</li>
<li>More predictable</li>
</ul>
<p></p>
<h3>Rigid Bodies in Game Engines</h3>
Almost every engine has rigid bodies built in:
<ul>
<li><strong>Unity</strong> → Rigidbody</li>
<li><strong>Unreal Engine</strong> → Physics Body / Chaos Physics</li>
<li><strong>Godot</strong> → RigidBody3D</li>
<li><strong>Custom engines</strong> → physics loop + collision system</li>
</ul>
The engine handles:
<ul>
<li>Physics calculations</li>
<li>Collision resolution</li>
<li>Time stepping</li>
</ul>

<p>You just define <strong>how objects should behave.</strong></p>
<p></p>

<h3>Why This Topic Is Important</h3>
<p>Understanding rigid bodies helps you:</p>
<ul>
<li>Make movement feel satisfying</li>
<li>Prevent bugs like clipping or jitter</li>
<li>Design believable worlds</li>
<li>Control physics instead of fighting it</li>
</ul>
<p>Rigid bodies are the <strong>bridge between visuals and interaction.</strong></p>
		
</p>
	
	</section>
	
	



<!--Topic: Collisions-->
		<section class="text_blocks">
        <h2 id="Collisions">Collisions</h2> 
        
        <p id="text_passage_one"> 
    
  <h3>What Is a Collision?</h3>
<p>A <strong>collision</strong> happens when two objects in a game <strong>touch or overlap</strong> and the game needs to <strong>react</strong> to it.</p>
Examples:
<ul>
<li>A player hitting a wall</li>
<li>A bullet striking an enemy</li>
<li>A ball bouncing on the floor</li>
</ul>
<p>>Without collision handling, objects would simply <strong>pass through each other.</strong></p>
<p></p>
<h3>Colliders (Collision Shapes)</h3>

<p>Games don’t usually calculate collisions using detailed models, that would be too slow. <br>
Instead, they use <strong>colliders</strong>: simplified shapes that represent an object’s physical space.</p>

Common collider shapes:
<ul>
<li><strong>Box</strong> – crates, buildings</li>
<li><strong>Sphere</strong> – balls, characters</li>
<li><strong>Capsule</strong> – players (smooth movement)</li>
<li><strong>Plane</strong> – ground</li>
<li><strong>Mesh</strong> – complex shapes (used carefully)</li>
</ul>
<p><strong>Simpler shapes = better performance.</strong></p>
<p></p>
<h3>Collision Detection vs Collision Response</h3>
Collision handling has two main steps:

<h4>1. Collision Detection</h4>
<ul>
<li>Checks if two objects intersect</li>
<li>Uses math and spatial algorithms</li>
<li>Happens every frame or physics step</li>
</ul>
<h4>2. Collision Response</h4>
<ul>
<li>Decides what happens next</li>
<li>Stop movement</li>
<li>Slide along surfaces</li>
<li>Bounce back</li>
<li>Trigger an event (damage, sound, score)</li>
</ul>
<p>Detection asks: <b>“Did they touch?”</b> <br>
Response asks: <b>“What should we do about it?”</b></p>
<p></p>
<h3>Triggers vs Physical Collisions</h3>
Not all collisions are physical.

<h4>Physical Collisions</h4>
<ul>
	<li>Objects push each other apart</li>
	<li>Used for walls, floors, obstacles</li>
</ul>

<h4>Triggers</h4>
<ul>
	<li>Detect overlap but don’t block movement</li>
	<li>Used for:</li>
	<ul>
	<li>Checkpoints</li>
	<li>Damage zones</li>
	<li>Pickups</li>
	<li>Area detection (AI vision, sound range)</li>
</ul>
</ul>

<p></p>
<h3>Layers and Collision Masks</h3>
<p>To improve performance and control behavior, games use <strong>layers</strong>. <br>
Examples:</p>
<ul>
	<li>Player</li>
	<li>Enemy</li>
	<li>Environment</li>
	<li>Projectiles</li>
</ul>
You can define rules like:
<ul></ul>
	<li>Player collides with Environment</li>
	<li>Projectiles collide with Enemies</li>
	<li>Player ignores Player</li>
</ul>
This avoids unnecessary collision checks and prevents bugs.

<p></p>

<h3>Continuous vs Discrete Collisions</h3>
Fast-moving objects can skip collisions if not handled correctly.

<h4>Discrete Collision</h4>
<ul>
<li>Checks positions per frame</li>
<li>Fast objects may “tunnel” through walls</li>
</ul>
<h4>Continuous Collision</h4>
<ul>
<li>Predicts movement between frames</li>
<li>Used for bullets or very fast objects</li>
</ul>

<h4>Common Collision Problems</h4>
<ul>
<li><strong>Clipping</strong> – object passes through another</li>
<li><strong>Jittering</strong> – object vibrates on surfaces</li>
<li><strong>Sticking</strong> – object gets caught on edges</li>
<li><strong>Tunneling</strong> – fast object misses collision</li>
</ul>

These are usually solved with:
<ul>
<li>Better colliders</li>
<li>Correct physics settings</li>
<li>Continuous collision detection</li>
</ul>

<h3>Collisions in Game Engines</h3>
Most engines handle collisions automatically:

<ul>
<li>Unity → Collider, OnCollision, OnTrigger</li>
<li>Unreal → Collision channels & responses</li>
<li>Godot → CollisionShape, signals</li>
</ul>
You focus on:
<ul>
<li>Choosing the right collider</li>
<li>Defining responses</li>
<li>Handling events</li>
</ul>
<p></p>
<h3>Why Collisions Are Crucial</h3>
Collisions define:
<ul>
<li>Where players can go</li>
<li>What objects can interact</li>
<li>How solid the world feels</li>
</ul>

<p>Good collision design makes a game feel <strong>tight, responsive, and polished</strong>.
Bad collisions instantly break immersion.</p>

</p>

	</section>
	
	





<!--Topic: Gravity & Forces-->
    	<section class="text_blocks">
        <h2 id="Gravity&Forces">Gravity & Forces</h2> 
        
        <p id="text_passage_one"> 
    <h3>What Is Gravity in Games?</h3>
<p><strong>Gravity</strong> is a constant force that pulls objects <strong>downward</strong>. <br>
In games, gravity:</p>
<ul>
	<li>Makes objects fall</li>
	<li>Gives jumps weight</li>
	<li>Keeps players grounded</li>
	<li>Defines what “up” and “down” mean</li>
</ul>
Unlike real life, game gravity is:
<ul>
	<li>Adjustable</li>
	<li>Directional</li>
	<li>Sometimes optional</li>
</ul>

You can make gravity:
<ul>
	<li>Stronger for snappy platformers</li>
	<li>Weaker for floaty movement</li>
	<li>Disabled for space or underwater scenes</li>
</ul>
<p></p>
<h3>What Is a Force?</h3>
<p>A <strong>force</strong> is anything that <strong>changes how an object moves</strong>. <br>
Forces can:</p>
<ul>
	<li>Start movement</li>
	<li>Stop movement</li>
	<li>Change direction</li>
	<li>Cause rotation</li>
</ul>
Examples:
<ul>
	<li>Player input (walking, jumping)</li>
	<li>Wind pushing objects</li>
	<li>Explosions</li>
	<li>Gravity itself</li>
</ul>
<h3>How Forces Affect Rigid Bodies</h3>
<p>Forces don’t directly change position, they change <strong>acceleration</strong>.
<br>
Basic idea:</p>
<ul>
	<li>Force → Acceleration → Velocity → Position</li>
</ul>

This is why:
<ul></ul>
	<li>Heavy objects accelerate slower</li>
	<li>Light objects react quickly</li>
	<li>Mass matters</li>
</ul>
<p></p>
<h3>Continuous Forces vs Impulses</h3>
There are two main ways to apply forces:

<h4>Continuous Forces</h4>
<ul>
	<li>Applied over time</li>
	<li>Example:</li>
	<ul>
		<li>Gravity</li>
		<li></li>Engine thrust</li>
		<li>Constant wind</li>
	</ul>
Result: smooth, gradual movement
</ul>
<h4>Impulses</h4>
<ul>
	<li></li>Applied instantly</li>
	<li>Example:</li>
	<ul>
		<li>Jump</li>
		<li>Explosion</li>
		<li>Bullet impact</li>
	</ul>

Result: sudden change in velocity
</ul>
<p></p>
<h3>Gravity and Jumping</h3>
Jumping is usually done by:
<ul></ul>
	<li>Applying an upward impulse</li>
	<li>Letting gravity pull the player back down</li>
</ul>
Good jump design depends on:
<ul>
	<li>Gravity strength</li>
	<li>Jump impulse</li>
	<li>Fall speed</li>
	<li>Air control</li>
</ul>
This is why jumping feels very different between games.
<p></p>
<h3>Directional and Custom Gravity</h3>
Gravity doesn’t have to point downward.
<br>
Examples:
<ul>
	<li>Planets with spherical gravity</li>
	<li>Rotating space stations</li>
	<li>Puzzle games with gravity switching</li>
	<li>Zero-gravity environments</li>
</ul>
<p>Many games treat gravity as just another force vector.</p>

<h3>Force Limits and Damping</h3>
To keep physics stable, engines use limits:
<ul></ul>
	<li><strong>Drag / Damping</strong> – slows movement over time</li>
	<li><strong>Max velocity</strong> – prevents infinite speed</li>
	<li><strong>Force caps</strong> – keeps forces realistic</li>
</ul>
Without these:
<ul></ul>
	<li>Objects could slide forever</li>
	<li>Velocities could explode</li>
	<li>Physics becomes unstable</li>
</ul>
<h3>Gravity & Forces in Game Engines</h3>
Examples:
<ul>
	<li><strong>Unity</strong> → AddForce, ForceMode, gravity settings</li>
	<li><strong></strong>Unreal Engine</strong> → Forces, impulses, physics constraints</li>
	<li><strong>Godot</strong> → Forces applied per physics step</li>
</ul>
The engine handles the math — you decide:
<ul>
	<li>When to apply forces</li>
	<li>How strong they are</li>
	<li>How they interact</li>
</ul>

<h3>Why Gravity & Forces Matter</h3>
They define:
<ul>
	<li>Game feel</li>
	<li>Weight and responsiveness</li>
	<li>Realism vs fun balance</li>
</ul>
<p>Two games can use the same models and collisions,
but different gravity and force values make them feel completely different.</p>



</p>

	</section>
	
	





<!--Topic: Light & Shadows-->
<section class="text_blocks">
        <h2 id="Light&Shadows">Light & Shadows</h2> 
        
        <p id="text_passage_one"> 
    
  <h3>Why Light Matters in Games</h3>

<p>Light defines <strong>how players see your world.</strong><br>
Good lighting:</p>
<ul>
	<li>Creates atmosphere</li>
	<li>Shows depth and shape</li>
	<li>Guides player attention</li>
	<li>Makes environments believable</li>
</ul>
Without lighting, even high-quality models look flat and lifeless.
<p></p>
<h3>What Is Light in a Game Engine?</h3>

<p>In games, light is a <strong>mathematical simulation</strong>, not real photons.
<br>Lights affect:</p>
<ul>
	<li>Object color</li>
	<li>Brightness</li>
	<li>Contrast</li>
	<li>Shadow direction</li>
</ul>
<p>Most engines calculate lighting <strong>per frame</strong> in real time.</p>
<p></p>
<h3>Common Types of Lights</h3>

<h4>Directional Light</h4>
<ul>
	<li>Light with no visible source</li>
	<li>Same direction everywhere</li>
	<li>Used for: sun or moon</li>
</ul>

<h4>Point Light</h4>
<ul>
	<li>Emits light in all directions from one point</li>
	<li>Used for: lamps, torches, explosions</li>
</ul>

<h4>Spot Light</h4>
<ul>
	<li>Emits light in a cone</li>
	<li>Used for: flashlights, stage lights, headlights</li>
</ul>
<p></p>
<h3>Real-Time Lighting vs Baked Lighting</h3>

<h4>Real-Time Lighting</h4>
<ul>
	<li>Calculated every frame</li>
	<li>Lights and shadows can move</li>
	<li>More expensive performance-wise</li>
	<li>Used for dynamic objects and time-of-day systems</li>
</ul>

<h4>Baked Lighting</h4>
<ul>
	<li>Pre-calculated and stored</li>
	<li>Very fast at runtime</li>
	<li>Lights cannot move</li>
	<li>Used for static environments</li>
</ul>
Many games use a hybrid approach.
<p></p>
<h3>What Are Shadows?</h3>

<p>Shadows appear where light is blocked by an object.
<br>They:</p>
<ul>
	<li>Show object position</li>
	<li>Improve depth perception</li>
	<li>Make movement readable</li>
</ul>
Without shadows:
<ul>
	<li>Objects appear to float</li>
	<li>Distances are harder to judge</li>
</ul>
<p></p>
<h3>Types of Shadows</h3>

<h4>Hard Shadows</h4>

<ul>
	<li>Sharp edges</li>
	<li>Fast to render</li>
	<li>Look less realistic</li>
</ul>

<h4>Soft Shadows</h4>

<ul>
	<li>Blurred edges</li>
	<li>More realistic</li>
	<li>More performance-heavy</li>
</ul>

<p></p>
<h3>Shadow Techniques (Simplified)</h3>
<ul></ul>
	<li><strong>Shadow Maps</strong> – most common real-time method</li>
	<li><strong>Blob Shadows</strong> – fake shadows under characters</li>
	<li><strong>Baked Shadows</strong> – pre-computed, very cheap</li>
</ul>
Games often mix techniques for performance.
<p></p>
<h3>Lighting as a Gameplay Tool</h3>
<p>Lighting isn’t just visual it affects gameplay.
<br>Examples:</p>
<ul>
	<li>Dark areas hide enemies</li>
	<li>Bright paths guide the player</li>
	<li>Flickering lights build tension</li>
	<li>Shadows reveal movement</li>
</ul>
Many horror and stealth games rely heavily on lighting.

<h3>Performance Considerations</h3>
Lighting is expensive.

To optimize:
<ul>
	<li>Limit real-time lights</li>
	<li>Reduce shadow resolution</li>
	<li>Use baked lighting where possible</li>
	<li>Disable shadows on unimportant objects</li>
</ul>
Good lighting is about smart choices, not maximum quality.


<h3>Light & Shadows in Game Engines</h3>
<ul>
	<li>Unity → Light types, shadow settings, light baking</li>
	<li>Unreal Engine → Dynamic & Lumen lighting</li>
	<li>Godot → Lights, shadows, lightmaps</li>
</ul>
The engine handles rendering, you decide:
<ul>
	<li>Mood</li>
	<li>Visibility</li>
	<li>Performance balance</li>
</ul>
<p></p>
<h3>Why This Topic Is Important</h3>
Light and shadows:
<ul>
	<li>Define the mood of your game</li>
	<li>Make worlds readable</li>
	<li>Separate amateur projects from polished games</li>
</ul>

Great lighting can make simple geometry look amazing.
</p>

	</section>





<!--Topic: Particle Systems-->
	<section class="text_blocks">
        <h2 id="Particle_Systems">Particle systems</h2> 
        
        <p id="text_passage_one"> 
    
    <h3>What Is a Particle System?</h3>

<p>A <strong>particle system</strong> simulates a large number of <strong>small visual elements</strong> called particles.
<br>
Each particle is usually:</p>
<ul> 
	<li>A tiny sprite or mesh</li>
	<li>Short-lived</li>
	<li>Lightweight to render</li>
</ul>
<p>Individually they’re simple, but together they create complex effects.
<br>
Examples:</p>
<ul>
	<li>Fire</li>
	<li>Smoke</li>
	<li>Explosions</li>
	<li>Sparks</li>
	<li>Magic effects</li>
	<li>Rain, snow, dust</li>
</ul>
<p></p>
<h3>Why Games Use Particle Systems</h3>
Particle systems are used because they:
<ul>
	<li>Create dynamic effects cheaply</li>
	<li>Are highly customizable</li>
	<li>React well to gameplay events</li>
	<li>Add impact and feedback</li>
</ul>
<p>A single explosion effect might consist of <strong>hundreds of particles</strong> working together.</p>
<p></p>
<h3>How Particle Systems Work (Simplified)</h3>
A particle system has three main parts:

<h4>1. Emission</h4>
<ul>
	<li>How many particles are created</li>
	<li>When they are spawned (continuous or burst)</li>
</ul>

<h4>2. Particle Behavior</h4>
<ul>
	<li>Lifetime</li>
	<li>Speed</li>
	<li>Direction</li>
	<li>Size</li>
	<li>Color</li>
	<li>Gravity influence</li>
</ul>

<h4>3. Rendering</h4>
<ul>
	<li>How particles look on screen</li>
	<li>Sprite, mesh, glow, transparency</li>
</ul>

Particles are constantly:
<ul>
	<li>Spawned</li>
	<li>Updated</li>
	<li>Destroyed</li>
</ul>
<p></p>
<h3>Common Particle Behaviors</h3>
Particles can:
<ul>
	<li>Fade in or out</li>
	<li>Grow or shrink</li>
	<li>Change color over time</li>
	<li>Be affected by gravity</li>
	<li>Follow wind or turbulence</li>
	<li>Rotate or stretch with velocity</li>
</ul>
These small changes create believable motion.
<p></p>
<h3>Local Space vs World Space</h3>
<h4>Local Space</h4>
<ul>
	<li>Particles move with the object</li>
	<li>Used for: fire on a torch, engine exhaust</li>
</ul>
<h4>World Space</h4>
<ul>
	<li>Particles stay where they spawned</li>
	<li>Used for: explosions, smoke clouds</li>
</ul>
Choosing the right space is important for realism.
<p></p>
<h3>Particle Systems and Physics</h3>
Particles usually:
<ul>
	<li>Ignore collisions</li>
	<li>Have simple gravity</li>
	<li>Do not interact physically with the world</li>
</ul>
This keeps them fast.
<p></p>
Some systems allow:
<ul>
	<li>Collision with environment</li>
	<li>Bouncing or sliding</li>
	<li>Triggering events</li>
</ul>
Used carefully due to performance cost.
<p></p>
<h3>Particle Systems as Feedback</h3>
Particles communicate information to the player.
<br>
Examples:
<ul>
	<li>Hit sparks → successful attack</li>
	<li>Dust → fast movement</li>
	<li>Glow → interactable object</li>
	<li>Smoke → damage or danger</li>
</ul>
Good effects improve clarity, not just visuals.
<p></p>
<h3>Performance Considerations</h3>
Particle systems can be expensive if overused.
<br>
Optimization tips:
<ul>
	<li>Limit particle count</li>
	<li>Use simple textures</li>
	<li>Keep lifetimes short</li>
	<li>Avoid unnecessary collisions</li>
	<li>Disable off-screen effects</li>
</ul>
Many small effects beat one massive effect.

<h3>Particle Systems in Game Engines</h3>
<ul>
	<li>Unity → Particle System component</li>
	<li>Unreal Engine → Niagara / Cascade</li>
	<li>Godot → GPUParticles / CPUParticles</li>
</ul>
<p>Modern engines often run particles on the <strong>GPU</strong> for speed.</p>
<p></p>
<h3>Why Particle Systems Matter</h3>
Particle systems:
<ul>
	<li>Make actions feel powerful</li>
	<li>Add life to environments</li>
	<li>Improve player feedback</li>
	<li>Hide visual limitations elsewhere</li>
</ul>
They’re one of the biggest upgrades from “works” to “feels great”.


</p>

	</section>









	<!--
	<section class="text_blocks">
        <h2>Game Loop</h2> 
        
        <p id="text_passage_one"> 
    
    If there is one pattern this book couldn’t live without, this is it. Game loops are the quintessential example of a “game programming pattern”. Almost every game has one, no two are exactly alike, and relatively few programs outside of games use them.

To see how they’re useful, let’s take a quick trip down memory lane. In the olden days of computer programming when everyone had beards, programs worked like your dishwasher. You dumped a load of code in, pushed a button, waited, and got results out. Done. These were batch mode programs — once the work was done, the program stopped.
 </p>

	</section>
-->




 <script src="../Java_Scripts/Header.js"></script>
	</body>
	
	
		
	
	
	
	
	
	
	
</html>